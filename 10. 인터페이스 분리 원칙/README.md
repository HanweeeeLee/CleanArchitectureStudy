# 10. ISP: 인터페이스 분리 원칙
## 인터페이스 분리 원칙
인터페이스 분리 원칙은 아래의 다이어그램에서 그 이름을 유래했다.
![KakaoTalk_Photo_2021-11-28-20-22-44](https://user-images.githubusercontent.com/60125719/143765715-b21f8ec1-f066-4a0f-a513-2292aa0c5b91.jpeg)
User1은 오직 op1만을 사용한다고 가정해보자. 그리고 OPS가 정적 타입 언어로 작성된 클래스라고 해보자. user1에서는 op2와 op3를 전혀 사용하지 않음에도 User1의 소스코드는 이 두 메서드에 의존하게 된다. 이러한 의존성으로 인해 OPS클래스에서 op2의 소스코드가 변경되면 user1도 다시 컴파일한 후 새로 배포해야 한다. 사실 user1과 관련된 코드는 변경되지 않았다.
![KakaoTalk_Photo_2021-11-28-20-27-19](https://user-images.githubusercontent.com/60125719/143765816-b8d55a1d-77c4-4054-8e76-45d6ba40a033.jpeg)
->
User1의 소스코드는 U10ps와 op1에는 의존하지만 OPS에는 의존하지 않게 된다. 따라서 OPS에서 발생한 변경이 user1괴는 전혀 관계없는 변경이라면, User1을 다시 컴파일하고 새로 배포해야하는 상황은 일어나지 않는다.

## ISP와 언어
앞의 예제애서 본 사례는 언어 타입에 의존한다. 정적 타입 언어는 사용자가 import, use또는 include와 같은 타입 선언문을 사용하도록 강제한다. 이처럼 소스코드에 포함된(includ)선언문으로 인해 소스코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다.  루비나 파이썬과 같은 동적 타입 언어에서는 소스 코드에 이러한 선언문이 존재하지 않는다. 대신 런타임에 추론이 발생한다. 따라서 소스 코드 의존성이 아예 없으며, 결국 재컴파일과 재배포가 필요 없다.  
이러한 사실로 인해 ISP를 아키텍처가 아니라, 언어와 관련된 문제라고 결론내릴 여지가 있다.

## ISP와 아키텍쳐
일반적으로 필요 이상으로 많은걸 포함하는 모듈에 의존하는 것은 해로운 일이다. -> 불필요한 재컴파일과 재배포를 강제하기 때문! 하지만 더 고수준인 아키텍처 수준에서도 마찬가지 상황이 발생한다.  
![KakaoTalk_Photo_2021-11-28-20-33-42](https://user-images.githubusercontent.com/60125719/143766003-9a7f43b1-c508-4544-824b-bfa814464437.jpeg)
> S의 개발자들이 F를 도입했는데 의존성이 걸려있는 전혀 관계없는 기능의 D때문에 S를 다시 배포해야하는 상황이 올 수 있다.

## 결론
여기서 배울 수 있는 교훈은 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다는 사실이다.






















































