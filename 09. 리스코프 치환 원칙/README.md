# 09. LSP: 리슼코프 치환 원칙

## 상속을 사용하도록 가이드하기
![KakaoTalk_Photo_2021-11-28-19-55-45](https://user-images.githubusercontent.com/60125719/143764966-caa20940-c896-4b3b-bdd3-256db3116f80.jpeg)
> 이 설계는 LSP를 준수하는데, Billing 애플리케이션의 행위가 License 하위타입 중 무엇을 사용하는지에 전혀 의존하지 않기 때문이다. 이들 하위타입은 모두 License타입을 치환할 수 있다.

## 정사각형/직사각형 문제
![KakaoTalk_Photo_2021-11-28-20-04-01](https://user-images.githubusercontent.com/60125719/143765184-a557d583-3956-446c-b6bd-8ed87867a913.jpeg)
> 이 예제에서 Squre는 Rectangle의 하위타입으로는 적합하지 않은데, Rectangle의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면, Square의 높이와 너비는 반드시 함께 변경되기 때문

```Java
Rectangle r = ...
r.setW(5);
r.setH(2);
assert(r.area() == 10);
```
> 실패한다.  

이런 형태의 LSP위반을 막기 위한 유일한 방법은(if문 등을 이용해서) Rectangle이 실제로는 Square인지를 검사하는 메커니즘을 User에 추가하는 것이다. 하지만 이렇게 하면 User의 행위가 사용하는 타입에 의존하게 되므로 결국 타입을 서로 치환할 수 없게 된다.

## LSP와 아키텍쳐
객체지향이 처음 나왔을때는 LSP는 상속에 대한 가이드 정도였지만 이젠 소프트웨어 설계원칙이 되었다.

## LSP 위배 사례
### 택시 파견 서비스의 예시
### 요구사항
1. 고객은 어느 택시업체인지는 신경쓰지 않고 자신의 상황에 가장 적합한 택시를 찾는다.
2. 고객이 이용할 택시를 결정하면, 시스템은 REST서비스를 통해 선택된 택시를 고객 위치로 파견한다.
3. 시스템이 고객에게 알맞은 기사를 선택하면 해당 기사의 레코드로부터 URI정보를 얻은 다음, 그 URI정보를 이용하여 해당 기사를 고객 위치로 파견한다.
### 요구사항에 대한 예시
```
purplecab.com/driver/Bob
```
> 택시기사 Bob의 택시 파견 URI.  

시스템은 이 URI에 파견에 필요한 정보를 덧붙인 후 아래와 같이 PUT방식으로 호출한다
```
purplecab.com/driver/Bob
/pickupAddress/24 Maple St.
/pickupTime/153
/destination/ORD
```
### 문제의 시작
택시 업체 애크미에서 프로그래머를 몇 명 고용했는데, 이들이 서비스 사양서를 그다지 신중하게 읽지 않았다. 그래서 destination필드를 dest로 축약해서 사용해버렸다.  
그런데 애크미는 이 지역에서 가장 큰 택시업체일 뿐만 아니라, 애크미 대표의 전처는 우리 회사 대표의 아내가 되었다.  
우리는 이 예외사항을 처리하는 로직을 추가해야만 할 것이다.  
애크미 소속기사를 파견하는 요청은 나머지 업체의 기사를 파견할 때 와는 다른 규칙을 이용하여 구성해야만 한다.  
이를 위한 가장 간단한 방법은 파견 명령어를 구성하는 모듈에 if문장을 추가하는 것이다.
```
if (driver.getDispatchUri().startWith("acme.com"))...
```
### 결론은?
하지만 실력있는 아키텍트라면 당연히 시스템을 이런 식으로 구성하는 것을 용납하지 않는다. "acme"라는 단어를 코드 자체에 추가하면, 끔찍할 뿐만 아니라 이해할 수도 없는 온갖 종류의 에러가 발생할 여지를 만들게 된다.  
예를 들어 애크미가 지금보다 더 성장해서 다른 택시업체인 퍼플을 인수한다면? if를 또 추가해야하나?  
아키텍트는 이 같은 버그로부터 시스템을 격리해야 한다. 
![KakaoTalk_Photo_2021-11-28-20-18-35](https://user-images.githubusercontent.com/60125719/143765607-269ad8e5-b759-40d3-bf0f-cc05b4b70916.jpeg)
또한 아키텍트는 REST 서비스들의 인터페이스가 서로 치환 가능하지 않다는 사실을 처리하는 중요하고도 복잡한 매커니즘을 추가해야 한다.

## 결론
LSP는 아키텍쳐 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환가능성을 조금이라도 위배하면 시스템 아키텍쳐가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.















































