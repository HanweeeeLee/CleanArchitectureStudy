# 16. 독립성
좋은 아키텍처는 다음을 지원해야 한다. 
 - 시스템의 유스케이스 
 - 시스템의 운영
 - 시스템의 개발
 - 시스템의 배포


## 유스케이스
시스템 아키텍처는 시스템의 의도를 지원해야 한다.  
실제로 아키텍트의 최우선 관심사는 유스케이스이며, 아키텍처에서도 유스케이스가 최우선이다.  
좋은 아키텍처가 행위를 지윈하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.  

## 운영
시스템의 운영 지원 관점에서 볼 떄 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다. 시스템이 초당 100,000명의 고객을 처리해야 한다면, 이카텍처는 이 요구와 관련된 각 유스케이스에 걸맞는 처리량과 응답시간을 보장해야 한다.  
각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬어질 것이다.

## 개발
아키텍처는 개발환경을 지원하는 데 있어 핵심적인 역할을 수행한다. 콘웨이(Conway)의 법칙이 적용하는 지점이 이곳이다.  
> 콘웨이의 법칙? 시스템을 설계하는 조직이라면 어디든지 그 조직이 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.  
각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로를 발해하지 않도록 해야한다. 이렇게 하기 위해서는 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할 할 수 있어야 한다.  

## 배포
목표는 즉각적인 배포(immediate deployment)다. 좋은 아키텍처는 수십 개의 작은 설정 스크립트나 속성 파일을 약간씩 수정하는 방식을 사용하지 않는다. 좋은 아키텍처는 꼭 필요한 디렉터리나 파일을 수작업으로 생성하게 내버려 두지 않는다. 좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.  
이러한 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.

## 선택사항 열어놓기
좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.

## 계층 결합 분리
아키텍터는 필요한 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만, 유스케이스 전부를 알지 못한다. 하지만 시스템의 기본적인 의도는 알고 있다.  
아미텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶는다.  

## 유스케이스 결합 분리
유스케이스는 서로 다른 이유로 변경이 된다. ex) 주문 입력 시시틈에서 주문을 추가하는 유스케이스는 주문을 삭제하는 유스케이스와는 다른속도로, 다른이유로 변경된다.  
이와 동시에 유스케이스는 시스템의 수평적인 계층을 가로지르도록 자른, 수직적으로 좁다란 조각이기도 하다.  ex) 주문 추가 유스케이스의 UI와 주문 삭제 유스케이스의 UI를 분리해야하고, 업무규칙과 데이터베이스 부분도 마찬가지.  
이런 식으로 시스템 맨 아래 계층까지 수직으로 내려가며 유스케이스들이 각 계층에서 서로 겹치지 않게 한다.  

## 결합 분리 모드

![KakaoTalk_Photo_2021-12-19-20-27-55](https://user-images.githubusercontent.com/60125719/146673279-8ad2b00f-0110-4385-9007-614bb64584c3.jpeg)

유스케이스를 위해 수행하는 그 작업들(결합 분리)은 운영에도 도움이 된다.

운영 측면에서 이러한 장점을 살리기 위해선 결합을 분리할 때 적절한 모드를 선택해야 한다.(컴포넌트를 서비스 단계까지 나눌 수 도 있음)
실제로 서비스에 기반한 아키텍처를 흔히 서비스 지향 아키텍처(serice-oriented-architecture, SOA)라고 부른다.

ex) 마이크로 서비스(micro-serice) 등


## 개발 독립성
컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다. 유스케이스 자체도 서로 결합이 분리되면 addOrder 유스케이스에 중점을 둔 팀이 deleteOrder 유스케이스에 중점을 둔 팀에 개입할 가능성은 거의 없다.   

## 배포 독립성
결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 교체(hot-swap)할 수 있다.  
새로운 유스케이스를 추가하는 일은 시스템의 나머지는 그대로 둔 채 새로운 jar파일이나 서비스 몇개를 추가할 정도로 단순해진다.  

## 중복
소프트웨어에서 중복은 일반적으로 나쁜 것이다.  
하지만 중복에도 여러 종류가 있다. 
 - 진짜 중복. 이 경우 한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 한다.  
 - 우발적인 중복. 중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면, 즉 서로 다른 속도와 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아니다.  


## 결합 분리 모드(다시)
계층과 유스케이스의 결합을 분리하는 방법은 다양하다. 소스코드 수준에서 분리할 수도 있으며, 바이너리 코드(배포)수준에서도, 그리고 실행 단위(서비스) 수준에서도 분리할 수 있다.

 - 소스 수준 분리 모드: 소스 코드 모듈 사이의 의존성을 제어할 수 있다. 이를 통해 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있다.
 - 배포 수준 분리 모드: jar파일, DLL, 공유라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다. 이를 통해 한 모듈의 소스코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있다. 
 - 서비스 수준 분리 모드: 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고, 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다. 이를 통해 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해서 서로 완전히 독립적이게 된다. (ex) 서비스 또는 마이크로서비스)

 좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고, 또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야한다. 또한 좋은 아키텍처라면 나중에 상황이 바뀌었을 때 이 진행 방향을 거꾸로 돌려 원래 형태인 모노리틱 구조로 되돌릴 수도 있어야 한다. 
 

































