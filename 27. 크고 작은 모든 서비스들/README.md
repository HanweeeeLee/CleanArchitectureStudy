# 27. 크고 작은 모든 서비스들
서비스 지향 아키텍처와 마이크로 서비스 아키텍처의 인기 이유는 다음과 같다
 - 서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보인다. 이는 일부만 맞는 말이다.
 - 서비스를 사용하면 개발과 배포 독립성을 지원하는 것처럼 보인다. 이 역시도 일부만 맞는 말이다.


## 서비스 아키텍처?
서비스를 사용한다는 것이 아키텍처를 사용한다는것은 아니다. 시스템의 아키텍처는 의존성 규칙을 준수하고 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다.  
단순히 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과하다.  
서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다.  

## 서비스의 이점?
### 1. 결합 분리의 오류
서비스 사이의 결합이 확실히 분리된다.  
어쨋든 각 서비스는 서로 다른 프로세스에서, 심지어는 서로 다른 프로세스에서 실행된다. 따라서 서비스는 다른 서비스의 변수에 직접 접근할 수 없다. 그리고 모든 서비스의 인터페이스는 잘 정의되어 있어야 한다.  
->  
하지만 프로세서 내의 또는 네트워크 상의 공유 자원 때문에 결합 될 수도 있으며, 서로 공유하는 데이터에 의해 이들 서비스는 강력하게 결합될 수 있다..  
서비스의 인터페이스가 잘 정의되어있는것도 함수의 경우와 별반 차이가 없다.  
### 2. 개발 및 배포 독립성의 오류
전담팀이 서비스를 소유하고 운영한다.  
전담팀에서 각 서비스를 작성하고, 유지보수하며, 운영하는 책임을 질 수 있다. 이러한 개발 및 배포 독립성은 확장 가능한 것으로 간주된다.  
->   
극히 일부일 뿐이다.
 - 대규모 엔터 프라이즈 시스템은 서비스 기반 시스템 이외에도, 모노리틱 시스템이나 컴포넌트 기반 시스템으로도 구축할 수 있다
 - '결합 분리의 오류'에 따르면 서비스라고 해서 항상 독립적으로 개발하고, 배포하며, 운영할 수 있는 것은 아니다. 데이터나 행위에서 어느 정도 결합되어 있다면 결합된 정도에 맞게 개발, 배포, 운영을 조정해야만 한다. 

## 야옹이 문제
앞에서 언급했던 택시 통합 시스템을 다시 살펴보자.  
<img width="763" alt="(2)" src="https://user-images.githubusercontent.com/60125719/149528205-fe01bb54-1567-4ddc-8b77-4229688776fe.png">
1. Taxi UI - 고객 담당, 고객은 모바일 기기를 이용해 택시 호출
2. TaxiFinder - Taxi Supplier 현황을 검토하여 사용자에게 적합한 택시 후보들을 선별
3. TaxiSelector - 택시를 TaxiDispatcher로 전달
4. TaxiDispatcher - 해당 택시에 배차 지시

확장 가능성을 위해 위처럼 수많은 작은 마이크로 서비스를 기반으로 한 택시 통합 시스템이 있다면 도시에 야옹이를 배달하는 서비스를 위해 어느 서비스를 수정해야 할까?  
위 서비스들은 모두 결합되어 잇으며 독립적으로 개발하고 배포하거나 유지될 수 없다.

## 객체가 구출하다
컴포넌트 기반 아키텍처에서는 이 문제를 어떻게 해결했을까?
![KakaoTalk_Photo_2022-01-14-23-14-08](https://user-images.githubusercontent.com/60125719/149529281-a1384a3c-bfc5-4743-996f-97a7bbde9269.jpeg)
> 의존성들이 의존성 규칙을 준수한다는 점을 주목하자

배차에 특화된 로직 부분은 Rides 컴포넌트로 추출되고, 야옹이에 대한 신규 기능은 Kittens 컴포넌트에 들어갔다. 이 두 컴포넌트는 기존 컴포넌트들에 있는 추상 기반 클래스를 탬플릿 메서드(Template Method)나 전략(Strategy) 패턴 등을 이용해서 오버라이드한다.  
TaxiUI는 변경해야하지만 그 외의 것들은 변경할 필요가 없다.  
따라서 야옹이 기능은 결합이 분리되며, 독립적으로 개발하여 배포할 수 있다. 

## 컴포넌트 기반 서비스
서비스에도 이렇게 할 수 있을까?  
서비스가 반드시 소규모 단일체여야 할 이유는 없다. 서비스는 SOLID원칙대로 설계할 수 있으며 컴포넌트 구조를 갖출 수도 있다. 이를 통해 서비스 내의 기존 컴포넌트들을 변경하지 않고도 새로운 컴포넌트를 추가할 수 있다.  
![(3)](https://user-images.githubusercontent.com/60125719/149531659-5230d0c1-7058-4f76-bacc-bac48b0cfff3.jpeg)
자바의 경우 서비스를 하나 이상의 jar 파일에 포함되는 추상 클래스들의 집합이라고 생각하자  
새로운 기능 추가, 기능 확장 -> 새로운 jar 파일  
새로운 jar 파일을 구성하는 클래스들은 기존의 jar 파일에 정의된 추상 클래스들을 확장하여 생성 
-> 개방 폐쇄 원칙을 준수하게 된다.  

## 횡단 관심사
<img width="460" alt="(5)" src="https://user-images.githubusercontent.com/60125719/149532028-0c57f20b-80fb-4486-9fa9-7f92001893c1.png">
아키텍처의 경계는 서비스 사이에 있지 않다. 오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분리한다.  
따라서 서비스 내부는 의존성규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다. 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트 이다.



































