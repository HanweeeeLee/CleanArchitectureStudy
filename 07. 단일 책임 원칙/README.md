# 07. SRP: 단일 책임 원칙
하나의 모듈은 하나의 액터에 대해서만 책임져야 한다.  
이 원칙을 이해하는 가장 좋은 방법은 이 원칙을 위반하는 징후들을 살펴보는것이 좋다.  

## 징후 1: 우발적 중복
![KakaoTalk_Photo_2021-11-14-21-13-46](https://user-images.githubusercontent.com/60125719/141680569-811c2dc5-3bad-47a5-b0a6-f8817d3289bd.jpeg)
이 클래스는 SRP를 위반하는데, 이들 세가지 메서드가 서로 매우 다른 세 명의 액터를 책임지기 때문이다.  
 - calculatePay() 메서드는 회계팀에서 기능을 정의하며, CFO보고를 위해 사용한다.
 - reportHours() 메서드는 인사팀에서 기능을 정의하고 사용하며, COO보고를 위해 사용한다.
 - save() 메서드는 데이터베이스 관리자가 기능을 정의하고, CTO보고를 위해 사용한다.

개발자가 이 세 메서드를 Employee라는 단일 클래스에 배치하여 세 액터가 서로 결합되어 버렸다.  
예를들어 calculatePay() 메서드와 reportHours() 메서드가 초과 근무를 제외한 업무 시간을 계산하는 알고리즘을 공유한다고 해보자. 그리고 개발자는 코드 중복을 피하기 위해 이 알고리즘을 regularHours()라는 메서드에 넣었다고 해보자.  
![KakaoTalk_Photo_2021-11-14-21-18-25](https://user-images.githubusercontent.com/60125719/141680705-ad61e276-4664-4c73-b035-1c6fc18baffe.jpeg)
CFO팀에서 초과 근무를 제외한 업무 시간을 계산하는 방식을 수정해달라는 요청이 들어왔다. 그런데 COO팀에서는 초과 근무를 제외한 업무 시간을 CFO팀과는 다른 목적으로 사용하기 때문에, 이 같은 변경을 원하지 않는다고 해보자.  
개발자는 calculatePay() 메서드가 편의 메서드인 regularHours()를 호출한다는 사실을 발견했다. 하지만 안타깝게도 이 함수가 reportHours() 메서드에서 호출된다는 사실은 눈치채지 못한다.  
이 수정사항은 배포가 되었고, COO팀은 이 일이 벌어진지 알지 못한다. 이제 COO팀이 받아보는 데이터는 reportHours()메서드가 생성한 잘못된 데이터이다.  

## 징후2: 병합
소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생한다.  
예를들어 DBA가 속한 CTO 팀에서 데이터베이스의 Employee 테이블 스키마를 약간 수정하기로 결정했다. 이와 동시에 인사 담당자가 속한 COO팀에서 reportHours() 메서드의 보고서 포맷을 변경하기로 결정했다.  
두 명의 서로 다른 개발자가, 그리고 아마도 서로 다른 팀에 속했을 두 개발자가 Employee 클래스를 체크아웃 받은 후 변경사항을 적용하기 시작한다.  
안타깝게도 이들 변경사항은 서로 충돌한다. 결과적으로 병합이 발생한다.  
이 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.  

## 해결책
이 문제의 해결책은 다양하다 

### 모두가 메서드를 각기 다른 클래스로 이동 시키는 방식
아무런 메서드가 없는 간단한 데이터 구조인 EmployeeData 클래스를 만들어, 세 개의 클래스가 공유하도록 한다.  
![KakaoTalk_Photo_2021-11-14-21-29-36](https://user-images.githubusercontent.com/60125719/141681121-0ad540f5-90c1-4f29-be01-769b3414b524.jpeg)
> 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다는 단점이 있다.

### 퍼사드(Facade) 패턴
![KakaoTalk_Photo_2021-11-14-21-29-19 001](https://user-images.githubusercontent.com/60125719/141681210-8ac850e2-2734-43c6-8cd1-b6668855bda2.jpeg)
EmployeeFacade 클래스는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 책임을 진다.  
어떤 개발자는 가장 중요한 업무 규칙을 데이터와 가깝게 배치하는 방식을 선호한다. 이 경우라면 가장 중요한 메서드는 기존의 Employee 클래스에 그대로 유지하되, Employee 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용할 수도 있다.  
![KakaoTalk_Photo_2021-11-14-21-29-20 002](https://user-images.githubusercontent.com/60125719/141681318-33a84741-934c-4bf3-8506-d8682d1a1a94.jpeg)













































