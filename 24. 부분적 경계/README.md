# 24. 부분적 경계
아키텍처 경계를 완벽하게 만드는 데에는 많은 비용이 든다. 
양방향으로 인터페이스를 정의하고, 입력과 출력에 대한 데이터 구조를 만들며, 독립적으로 컴파일 및 배포를 할 수 있도록 컴포넌트를 설계하고 의존성을 관리해야 한다. 
이러한 이유로 어떤 사람들은 경계를 완벽하게 만드는것이 과도하게 선행적인 설계라고 생각한다. 
너무 완벽한 경계를 구현하는데 과도한 비용이 들어간다면 경계를 부분적으로 구현하는것을 고려해볼 수 있다.

## 마지막 단계를 건너뛰기
부분적 경계를 생성하는 방법 하나는 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 것이다.
 - 쌍방향 인터페이스, 입력ㆍ출력 데이터 구조, 모든 것이 완전히 준비되어 있다.
 - 하지만 이 모두를 단일 컴포넌트로 컴파일 및 배포한다.
 - 다수의 컴포넌트를 관리하는 작업은 하지 않아도 되며 추적을 위한 버전 번호도 없으며, 배포 관리 부담도 없다.

## 일차원 경계
완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 Boundary 인터페이스를 사용한다. 
양방향으로 격리된 상태를 유지하려면 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 든다.
![다운로드](https://user-images.githubusercontent.com/50142323/148881276-980e4df7-db9d-4834-83b9-cf9fe459a1e7.png)
 - 위 이미지는 전통적인 전략(Strategy) 패턴 이다.
 - ServiceBoundary 인터페이스는 클라이언트가 사용하며 ServiceImpl 클래스가 구현한다.
 - Client를 ServiceImpl로 부터 격리 시키고자 의존성 역전 원칙을 적용한다.
 - 쌍방향 인터페이스가 없고 개발자와 아키텍트가 제대로 훈련되어 있지 않다면, 전략 패턴은 위에 점선과 같은 비밀 통로가 생길 수 있다.

## 퍼사드
훨씬 더 단순한 경계는 퍼사드 패턴이다.
![124385826-68109880-dd12-11eb-9ab8-583f485ed5a8](https://user-images.githubusercontent.com/50142323/148881713-281a1104-b24f-48ba-8cf1-4c7820c4a4c5.png)
의존성 역전은 희생하는 방법이고, 경계는 Facade 클래스로만 간단히 정의된다.
 - Facade class에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 클래스로 호출을 전달한다.
 - 클라이언트는 이들 서비스 클래스에 직접 접근할 수 없다.
 - 하지만 이 경우 Client가 모든 서비스 클래스에 대해 추이 종속성을 가지게 된다. -> 서비스 클래스 하나가 변경되면 클라이언트도 무조건 재 컴파일 해야한다.
