# 11. DIP: 의존성 역전 원칙
의존성 역전 원칙에서 말하는 '유연성이 극대화된 시스템'이란 소스 코드 의존성이 추상(abstraction)에 의존하며 구체(concretion)에는 의존하지 않는 시스템이다.  
Q) 하지만 String같은 클래스는 추상클래스가 아닌데?  
A) String과 같은 변경될 확률이 없다싶이 한 안정된 클래스는 상관이 없다. 변경 될 가능성이 충분한 클래스에 대해서 얘기하는것

## 안정된 추상화
안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처  
다음과 같은 코딩 실천법을 실천해보자
 - 변동성이 큰 구체 클래스를 참조하지 말라.
 - 변동성이 큰 구체 클래스로부터 파생하지 말라.
 - 구체 함수를 오버라이드 하지 말라.
 - 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.

## 팩토리
이 규칙들을 준수하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 한다.

![KakaoTalk_20211129_163427528](https://user-images.githubusercontent.com/60125719/143826414-d23c22d3-4098-4b8a-ab61-619b16c88c59.jpg)
> 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생한다. 이걸 가능한 바람직하도록 만드는 패턴이 팩토리 패턴이다. 
 - 이 그림에서 곡선은 구체적인 것들로부터 추상적인 것들을 분리한다. 
 - 제어 흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다는 점을 주목하자.

## 구체 컴포넌트
위의 그림에서 구체 컴포넌트에는 구체적인 의존성이 하나 있고, 따라서 DIP에 위반된다. 이는 일반적인 일이다.  
DIP위배를 모두 없앨 수는 없지만 DIP를 위반하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 분리할 수 있다.  

## 결론
위의 그림의 곡선은 이후 장에서는 아키텍쳐 경계가 될 것이다. 그리고 의존성은 이 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다. 