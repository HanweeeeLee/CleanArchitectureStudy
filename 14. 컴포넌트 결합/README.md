# 14. 컴포넌트 결합

## ADP: 의존성 비순환 원칙
> 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.

하루종일 일해서 무언가 작동하게 만들어 놓고 퇴근했는데, 다음날 출근해보니 전혀 안돌아간다? 알보고니 누군가 나의코드가 의존하고 있는 코드를 수정했기 때문..  
이런 문제를 해결하는 방법
1. 주 단위 빌드
2. 의존성 비순환 원칙

### 주 단위 빌드(Weekly Build)
#### 주 단위 빌드를 하는 방법
1. 모든 개발자는 일주일의 첫 4일 동안은 서로를 신경 쓰지 않는다.
2. 금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.  

-> 안타깝게도 프로젝트가 커지면 프로젝트 통합은 금요일 하루에 끝내는게 불가능해진다.  

### 순환 의존성 제거하기
#### 이 문제의 해결택은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다.
-> 컴포넌트는 개별 개발자가 또는 단일 팀이 책임질 수 있는 작업 단위가 된다.  
-> 개발자가 해당 컴포넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리즈 하여 다른 개발자가 사용할 수 있도록 만든다.   
담당 개발자는 이 컴포넌트에 릴리즈 번호를 부여하고, 다른 팀에서 사용할 수 있는 디렉터리로 이동시킨다.  
-> 개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다. 나머지 개발자는 릴리즈 된 버전을 사용한다.  
-> 컴포넌트가 새로 릴리즈되면 다른팀에서 해당 릴리즈버전을 사용할지 안할지 결정하고, 사용한다.  
  
따라서 어떤 팀도 다른 팀에 좌우되지 않는다. 특정 컴포넌트가 변경되더라도 다른팀에 즉각 영향을 주지 않는다.  
이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다.  

![image-14 1](https://user-images.githubusercontent.com/60125719/146661298-ca13e0e8-1a72-4186-873d-41a2d2013d26.png)
> 이 구조는 비순환 방향 그래프(Directed Acyclic Graph)다.  
  
이제 Presenters를 담당하는 팀에서 이 컴포넌트의 새로운 릴리즈를 만들면 의존성 화살표를 거꾸로 따라가면 릴리즈에 영향을 받는 팀을 쉽게 찾을 수 있다.  
또한 Main은 새로 릴리즈 되더라도 시스템에서 이로 인해 영향받는 컴포넌트가 전혀 없다는 사실에 주목하자. 

### 순환이 컴포넌트 의존성 그래프에 미치는 영향
새로운 요구사항이 발생하여 다음과 같이 변경되었다고 하자.  
![image-14 2](https://user-images.githubusercontent.com/60125719/146661406-abe83cd8-d736-48fc-8a48-810e739966d4.png)
  
이 순환은 즉각적인 문제를 일으킨다.  
1.  Database컴포넌트를 만드는 개발자는 컴포넌트를 릴리즈하려면 Entities 컴포넌트와 반드시 호환되어야 한다는 사실을 알고 있다. 하지만 Entities컴포넌트에는 순환이 있으므로, Database 컴포넌트 또한 Authorizer와 호환되어야 한다. 그런데 Autherizer는 Interractors에 의존한다. Entities, Authorizer, Interactors는 사실상 하나의 거대한 컴포넌트가 되어 버린다. 이 말은 결국 개발자들은 모두, 이들 컴포넌트 중 어느 것을 개발하더라도 '숙취 증후군'에 걸릴 수 있다.  
2. Entities 컴포넌트를 테스트 할 때 Authorizer와 Interactors까지도 반드시 빌드하고 통합해야 한다. 

### 순환 끊기
![image-14 3](https://user-images.githubusercontent.com/60125719/146661536-b636a424-3646-42eb-8f15-20d611d920e4.png)
 1. 의존성 역전 원칙을 적용한다.  
 위의 그림처럼 User가 필요로 하는 메서드를 제공하는 인터페이스를 생성한다. 그리고 해당 인터페이스는 Entities에 위치시키고, Authorizer에서는 이 인터페이스를 채택한다. 이렇게 하면 Entities와 Authorizer 사이의 의존성을 역전 시킬 수 있다.  
![image-14 4](https://user-images.githubusercontent.com/60125719/146661604-0fb77cf5-f872-40e7-84e4-19195fcab6cd.png)
 2. Entities외 Authorizer가 모두 의존하는 새로운 컴포넌트를 만든다. 그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.  


### 흐트러짐(Jitters)
요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다.  
따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야 한다. 순환이 발생하면 어떤 식으로든 끊어야 한다.

## 하양식(top-down) 설계
컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 떄 함께 진화한다.  
사실 컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없고 오히려 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도와 같다.  
프로젝트가 진행함에 따라 의존성 관리에 대한 요구가 늘어나고, 변경되는 범위가 시스템의 가능한 한 작은 일부로 한정되기를 원한다. 그래서 단일책임원칙과 공통 폐쇄 원칙에 관심을 갖기 시작하고, 이를 적용해 함께 변경되는 클래스는 같은 위치에 배치되도록 만든다.  
의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다.  
애플리케이션이 계속 성장함에 따라 우리는 재사용 가능한 요소를 만드는 일에 관심을 기울이기 시작한다. 공통 재사용 원칙(CRP)이 영향을 미치기 시작한다. 결국 순환이 발생하면 ADP가 적용되고 컴포넌트 의존성 그래프는 조금씩 흐트러지고 또 성장한다.  

## SDP: 안정된 의존성 원칙
> 안정성의 방향으로(더 안정된 쪽에) 의존하라.  
변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다.  
안정된 의존성 원칙(Stable Dependencies Principle, SDP)을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

### 안정성
![image-14 5](https://user-images.githubusercontent.com/60125719/146662768-88065e98-fd9a-4ec7-b0c9-32ccce9fc1e3.png)  
X는 안정된 컴포넌트다. 세 컴포넌트가 X에 의존하며, 따라서 X 컴포넌트는 변경하지 말아야 할 이유가 세 가지나 되기 때문이다. 이 경우 X는 세 컴포넌트를 책임진다(responsible)라고 말한다. 반대로 X는 어디에도 의존하지 않으므로 X가 변경되도록 만들 수 있는 외적인 영향이 전혀 없다. 이 경우 X는 독립적이다(independent)라고 말한다.   
  
![image-14 6](https://user-images.githubusercontent.com/60125719/146662822-1eb9a43a-96b8-4a49-b974-1991552dd26b.png)  
Y는 상당히 불안정한 컴포넌트다. 어떤 컴포넌트도 Y에 의존하지 않으므로 Y는 책임성이 없다고 말할 수 있다. 또한 Y는 세 개의 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부 요인이 세 가지다. 이 경우 Y는 의존적이라고 말한다.  

### 안정성 지표
어떻게 하면 컴포넌트 안정성을 측정할 수 있을까? 컴포넌트로 들어오고 나가는 의존성의 개수를 세어보자. 
 - Fan-in: 안으로 들어오는 의존성. 이 지표는 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수를 나타낸다. 
 - Fan-out: 바깥으로 나가는 의존성. 이 지표는 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수를 나타낸다. 
 - I(불안정성): I = Fan-out/(Fan-in + Fan-out). 이 지표는 [0, 1] 범위의 값을 갖는다. I = 0 이면 최고로 안정된 컴포넌트라는 뜻이고 I=1이면 최고로 불안정한 컴포넌트라는 뜻이다.  

![image-14 7](https://user-images.githubusercontent.com/60125719/146662928-86f3adeb-ad42-4a56-94ff-fa1a33fb32a4.png)
> ex) Cc 내부의 클래스에 의존하며 Cc 외부에 있는 클래스는 세 개다. Fan-in = 3  
> Cc 내부의 클래스가 의존하는 Cc 외부에 위치한 클래스는 한 개다. Fan-out = 1, I = 1/4

### 모든 컴포넌트가 안정적이어야 하는 것은 아니다

![image-14 8](https://user-images.githubusercontent.com/60125719/146662965-307ed0c2-497c-45ef-8144-812f0e2e5a1a.png)
> 세 컴포넌트로 구성된 시스템이 가질 수 있는 이상적인 구조.  
위쪽에는 변경 가능한 컴포넌트가 보이고, 아래의 안정된 컴포넌트에 의존한다.
> 다이어 그램에서 불안정한 컴포넌트를 관례적으로 위쪽에 둔다. 위배되는 걸 쉽게 찾기 위해! 

#### 추상 컴포넌트
오로지 인터페이스만을 포함하는 컴포넌트를 생성하는 방식인 추상 컴포넌트는 상당히 안정적이며, 따라서 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.

 - 동적 타입 언어(루비, 파이썬 등)같은 언어를 사용할 때는 이러한 추상 컴포넌트가 전혀 존재하지 않을 뿐만 아니라, 추상 컴포넌트로 향하는 의존성 같은 것도 전혀 없다.
 - 이들 언어에서 의존성 구조는 훨씬 단순한데, 의존성을 역전시킬 때 인터페이스를 선언하거나 상속받는 일이 전혀 필요하지 않기 때문이다.

## SAP: 안정된 추상화 원칙
> 컴포넌트는 안정된 정도만큼만 추상화되어야 한다. 

### 고수준 정책을 어디에 위치시켜야 하는가?
시스템에는 자주 변경해서는 절대로 안되는 소프트웨어도 있다. 고수준 아키텍처나 정책 결정과 관련된 소프트웨어가 그 예다. 따라서 시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트(I = 0)에 위치해야 한다.  
하지만 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스 코드는 수정하기가 어려워진다. 이로 인해 시스템 전체 아키텍처가 유연성을 잃는다.  
그렇다면 어떻게 컴포넌트가 최고로 안정된 상태이면서도(I = 0) 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있을까?  
해답은 개방 폐쐐 원칙(OCP)에서 찾을 수 있다.

### 안정된 추상화 원칙(Stable Abstraction Principle, SAP)
안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다. 이 원칙은 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다고 말한다. 다른 한편으로는 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말하는데, 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.  

### 추상화 정도 측정하기
다음은 컴포넌트의 클래스 총 수 대비 인터페이스와 추상 클래스의 개수를 단순히 계산한 값이다.
 - NC: 컴포넌트의 클래스 개수
 - Na: 컴포넌트의 추상 클래스와 인터페이스의 개수
 - A: 추상화 정도. A = Na / Nc(A가 0이면 추상 클래스가 한개도 없고, 1이면 오로지 추상 클래스만 있음)

### 주계열

이제 안정성(I)과 추상화 정도(A) 사이의 관계를 정리해보자

![image-14 12](https://user-images.githubusercontent.com/60125719/146663336-eb4c2fe0-0700-4d3c-83ef-414823575701.png)
> 최고로 안정적이며 추상화된 컴포넌트는 좌측 상단인 (0,1)에 위치한다. 최고로 불안정하며 구체화된 컴포넌트는 우측 하단인 (1,0)에 위치한다.  
모든 컴포넌트가 이 두 지점에 위치하지는 않는다. 

![image-14 13](https://user-images.githubusercontent.com/60125719/146663407-29cdba2d-f50d-4a27-86c1-8480858d6e34.png)
> 궤적은 컴포넌트가 절대로 위치해서는 안 되는 영역, 배제할 구역(Zone of Exclusion)이다.




















































